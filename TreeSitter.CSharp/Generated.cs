//----------------------
// <auto-generated>
//     Generated by node_generator.py
//     source: langs-native/tree-sitter-c-sharp/src/node-types.json
// </auto-generated>
//----------------------

#nullable enable

using System.Linq;

namespace TreeSitter.CSharp.Nodes {

    public abstract class CSharpLanguageNode
    {
        public static CSharpLanguageNode FromNode(TreeSitter.Node node) {
            if (node is null) throw new System.ArgumentNullException(nameof(node));
            if (!node.IsNamed) return new CSharpLanguageNodeTerminalNode(node);
            switch (node.Kind) {
                case "this_expression": return new ThisExpression(node);
                case "positional_pattern_clause": return new PositionalPatternClause(node);
                case "finally_clause": return new FinallyClause(node);
                case "ref_type": return new RefType(node);
                case "interface_declaration": return new InterfaceDeclaration(node);
                case "prefix_unary_expression": return new PrefixUnaryExpression(node);
                case "preproc_string_literal": return new PreprocStringLiteral(node);
                case "endregion_directive": return new EndregionDirective(node);
                case "case_switch_label": return new CaseSwitchLabel(node);
                case "break_statement": return new BreakStatement(node);
                case "primary_constructor_base_type": return new PrimaryConstructorBaseType(node);
                case "catch_declaration": return new CatchDeclaration(node);
                case "constructor_declaration": return new ConstructorDeclaration(node);
                case "string_literal_fragment": return new StringLiteralFragment(node);
                case "property_pattern_clause": return new PropertyPatternClause(node);
                case "tuple_element": return new TupleElement(node);
                case "bracketed_parameter_list": return new BracketedParameterList(node);
                case "type_of_expression": return new TypeOfExpression(node);
                case "generic_name": return new GenericName(node);
                case "ref_value_expression": return new RefValueExpression(node);
                case "compilation_unit": return new CompilationUnit(node);
                case "ref_type_expression": return new RefTypeExpression(node);
                case "stack_alloc_array_creation_expression": return new StackAllocArrayCreationExpression(node);
                case "local_declaration_statement": return new LocalDeclarationStatement(node);
                case "throw_expression": return new ThrowExpression(node);
                case "variable_declaration": return new VariableDeclaration(node);
                case "property_declaration": return new PropertyDeclaration(node);
                case "array_type": return new ArrayType(node);
                case "for_each_statement": return new ForEachStatement(node);
                case "checked_statement": return new CheckedStatement(node);
                case "line_directive": return new LineDirective(node);
                case "where_clause": return new WhereClause(node);
                case "type_constraint": return new TypeConstraint(node);
                case "tuple_expression": return new TupleExpression(node);
                case "cast_expression": return new CastExpression(node);
                case "delegate_declaration": return new DelegateDeclaration(node);
                case "real_literal": return new RealLiteral(node);
                case "enum_member_declaration_list": return new EnumMemberDeclarationList(node);
                case "struct_declaration": return new StructDeclaration(node);
                case "join_clause": return new JoinClause(node);
                case "global_attribute_list": return new GlobalAttributeList(node);
                case "if_directive": return new IfDirective(node);
                case "conversion_operator_declaration": return new ConversionOperatorDeclaration(node);
                case "member_binding_expression": return new MemberBindingExpression(node);
                case "nullable_type": return new NullableType(node);
                case "shebang_directive": return new ShebangDirective(node);
                case "function_pointer_unmanaged_calling_convention": return new FunctionPointerUnmanagedCallingConvention(node);
                case "object_creation_expression": return new ObjectCreationExpression(node);
                case "region_directive": return new RegionDirective(node);
                case "escape_sequence": return new EscapeSequence(node);
                case "attribute_target_specifier": return new AttributeTargetSpecifier(node);
                case "checked_expression": return new CheckedExpression(node);
                case "verbatim_string_literal": return new VerbatimStringLiteral(node);
                case "implicit_array_creation_expression": return new ImplicitArrayCreationExpression(node);
                case "from_clause": return new FromClause(node);
                case "order_by_clause": return new OrderByClause(node);
                case "do_statement": return new DoStatement(node);
                case "default_switch_label": return new DefaultSwitchLabel(node);
                case "member_access_expression": return new MemberAccessExpression(node);
                case "anonymous_method_expression": return new AnonymousMethodExpression(node);
                case "load_directive": return new LoadDirective(node);
                case "relational_pattern": return new RelationalPattern(node);
                case "local_function_statement": return new LocalFunctionStatement(node);
                case "type_parameter_constraint": return new TypeParameterConstraint(node);
                case "parameter_list": return new ParameterList(node);
                case "name_equals": return new NameEquals(node);
                case "subpattern": return new Subpattern(node);
                case "try_statement": return new TryStatement(node);
                case "destructor_declaration": return new DestructorDeclaration(node);
                case "select_clause": return new SelectClause(node);
                case "invocation_expression": return new InvocationExpression(node);
                case "name_colon": return new NameColon(node);
                case "range_expression": return new RangeExpression(node);
                case "switch_section": return new SwitchSection(node);
                case "global": return new Global(node);
                case "interpolation_alignment_clause": return new InterpolationAlignmentClause(node);
                case "constructor_constraint": return new ConstructorConstraint(node);
                case "assignment_operator": return new AssignmentOperator(node);
                case "interpolated_raw_string_text": return new InterpolatedRawStringText(node);
                case "modifier": return new Modifier(node);
                case "preproc_message": return new PreprocMessage(node);
                case "discard": return new Discard(node);
                case "element_binding_expression": return new ElementBindingExpression(node);
                case "declaration_pattern": return new DeclarationPattern(node);
                case "else_directive": return new ElseDirective(node);
                case "argument": return new Argument(node);
                case "and_pattern": return new AndPattern(node);
                case "enum_member_declaration": return new EnumMemberDeclaration(node);
                case "record_declaration": return new RecordDeclaration(node);
                case "function_pointer_parameter": return new FunctionPointerParameter(node);
                case "attribute": return new Attribute(node);
                case "array_rank_specifier": return new ArrayRankSpecifier(node);
                case "conditional_access_expression": return new ConditionalAccessExpression(node);
                case "for_statement": return new ForStatement(node);
                case "file_scoped_namespace_declaration": return new FileScopedNamespaceDeclaration(node);
                case "accessor_declaration": return new AccessorDeclaration(node);
                case "endif_directive": return new EndifDirective(node);
                case "join_into_clause": return new JoinIntoClause(node);
                case "variable_declarator": return new VariableDeclarator(node);
                case "field_declaration": return new FieldDeclaration(node);
                case "null_literal": return new NullLiteral(node);
                case "return_statement": return new ReturnStatement(node);
                case "lambda_expression": return new LambdaExpression(node);
                case "recursive_pattern": return new RecursivePattern(node);
                case "group_clause": return new GroupClause(node);
                case "indexer_declaration": return new IndexerDeclaration(node);
                case "query_continuation": return new QueryContinuation(node);
                case "declaration_expression": return new DeclarationExpression(node);
                case "function_pointer_calling_convention": return new FunctionPointerCallingConvention(node);
                case "character_literal_unescaped": return new CharacterLiteralUnescaped(node);
                case "implicit_stack_alloc_array_creation_expression": return new ImplicitStackAllocArrayCreationExpression(node);
                case "anonymous_object_creation_expression": return new AnonymousObjectCreationExpression(node);
                case "array_creation_expression": return new ArrayCreationExpression(node);
                case "elif_directive": return new ElifDirective(node);
                case "make_ref_expression": return new MakeRefExpression(node);
                case "negated_pattern": return new NegatedPattern(node);
                case "string_literal_encoding": return new StringLiteralEncoding(node);
                case "goto_statement": return new GotoStatement(node);
                case "default_expression": return new DefaultExpression(node);
                case "assignment_expression": return new AssignmentExpression(node);
                case "string_literal": return new StringLiteral(node);
                case "interpolation_format_clause": return new InterpolationFormatClause(node);
                case "pointer_type": return new PointerType(node);
                case "character_literal": return new CharacterLiteral(node);
                case "integer_literal": return new IntegerLiteral(node);
                case "element_access_expression": return new ElementAccessExpression(node);
                case "boolean_literal": return new BooleanLiteral(node);
                case "catch_filter_clause": return new CatchFilterClause(node);
                case "reference_directive": return new ReferenceDirective(node);
                case "comment": return new Comment(node);
                case "record_struct_declaration": return new RecordStructDeclaration(node);
                case "empty_statement": return new EmptyStatement(node);
                case "extern_alias_directive": return new ExternAliasDirective(node);
                case "using_directive": return new UsingDirective(node);
                case "using_statement": return new UsingStatement(node);
                case "switch_body": return new SwitchBody(node);
                case "as_expression": return new AsExpression(node);
                case "conditional_expression": return new ConditionalExpression(node);
                case "declaration_list": return new DeclarationList(node);
                case "implicit_object_creation_expression": return new ImplicitObjectCreationExpression(node);
                case "define_directive": return new DefineDirective(node);
                case "implicit_type": return new ImplicitType(node);
                case "interpolated_string_text": return new InterpolatedStringText(node);
                case "enum_declaration": return new EnumDeclaration(node);
                case "yield_statement": return new YieldStatement(node);
                case "tuple_pattern": return new TuplePattern(node);
                case "type_pattern": return new TypePattern(node);
                case "is_pattern_expression": return new IsPatternExpression(node);
                case "equals_value_clause": return new EqualsValueClause(node);
                case "global_statement": return new GlobalStatement(node);
                case "while_statement": return new WhileStatement(node);
                case "operator_declaration": return new OperatorDeclaration(node);
                case "with_expression": return new WithExpression(node);
                case "lock_statement": return new LockStatement(node);
                case "event_field_declaration": return new EventFieldDeclaration(node);
                case "case_pattern_switch_label": return new CasePatternSwitchLabel(node);
                case "event_declaration": return new EventDeclaration(node);
                case "switch_statement": return new SwitchStatement(node);
                case "block": return new Block(node);
                case "fixed_statement": return new FixedStatement(node);
                case "postfix_unary_expression": return new PostfixUnaryExpression(node);
                case "throw_statement": return new ThrowStatement(node);
                case "function_pointer_type": return new FunctionPointerType(node);
                case "attribute_argument_list": return new AttributeArgumentList(node);
                case "parenthesized_expression": return new ParenthesizedExpression(node);
                case "explicit_interface_specifier": return new ExplicitInterfaceSpecifier(node);
                case "parameter_modifier": return new ParameterModifier(node);
                case "constant_pattern": return new ConstantPattern(node);
                case "namespace_declaration": return new NamespaceDeclaration(node);
                case "preproc_integer_literal": return new PreprocIntegerLiteral(node);
                case "interpolated_verbatim_string_text": return new InterpolatedVerbatimStringText(node);
                case "scoped_type": return new ScopedType(node);
                case "query_expression": return new QueryExpression(node);
                case "switch_expression": return new SwitchExpression(node);
                case "continue_statement": return new ContinueStatement(node);
                case "class_declaration": return new ClassDeclaration(node);
                case "warning_directive": return new WarningDirective(node);
                case "undef_directive": return new UndefDirective(node);
                case "let_clause": return new LetClause(node);
                case "when_clause": return new WhenClause(node);
                case "error_directive": return new ErrorDirective(node);
                case "slice_pattern": return new SlicePattern(node);
                case "type_parameter_constraints_clause": return new TypeParameterConstraintsClause(node);
                case "attribute_list": return new AttributeList(node);
                case "identifier": return new Identifier(node);
                case "accessor_list": return new AccessorList(node);
                case "implicit_parameter_list": return new ImplicitParameterList(node);
                case "alias_qualified_name": return new AliasQualifiedName(node);
                case "or_pattern": return new OrPattern(node);
                case "catch_clause": return new CatchClause(node);
                case "initializer_expression": return new InitializerExpression(node);
                case "constructor_initializer": return new ConstructorInitializer(node);
                case "interpolation": return new Interpolation(node);
                case "argument_list": return new ArgumentList(node);
                case "base_list": return new BaseList(node);
                case "with_initializer_expression": return new WithInitializerExpression(node);
                case "expression_colon": return new ExpressionColon(node);
                case "predefined_type": return new PredefinedType(node);
                case "type_parameter_list": return new TypeParameterList(node);
                case "var_pattern": return new VarPattern(node);
                case "nullable_directive": return new NullableDirective(node);
                case "bracketed_argument_list": return new BracketedArgumentList(node);
                case "type_parameter": return new TypeParameter(node);
                case "simple_assignment_expression": return new SimpleAssignmentExpression(node);
                case "tuple_type": return new TupleType(node);
                case "raw_string_literal": return new RawStringLiteral(node);
                case "list_pattern": return new ListPattern(node);
                case "is_expression": return new IsExpression(node);
                case "parameter": return new Parameter(node);
                case "pragma_directive": return new PragmaDirective(node);
                case "size_of_expression": return new SizeOfExpression(node);
                case "type_argument_list": return new TypeArgumentList(node);
                case "labeled_statement": return new LabeledStatement(node);
                case "await_expression": return new AwaitExpression(node);
                case "binary_expression": return new BinaryExpression(node);
                case "expression_statement": return new ExpressionStatement(node);
                case "interpolated_string_expression": return new InterpolatedStringExpression(node);
                case "parenthesized_variable_designation": return new ParenthesizedVariableDesignation(node);
                case "qualified_name": return new QualifiedName(node);
                case "arrow_expression_clause": return new ArrowExpressionClause(node);
                case "if_statement": return new IfStatement(node);
                case "switch_expression_arm": return new SwitchExpressionArm(node);
                case "unsafe_statement": return new UnsafeStatement(node);
                case "base_expression": return new BaseExpression(node);
                case "ref_expression": return new RefExpression(node);
                case "attribute_argument": return new AttributeArgument(node);
                case "function_pointer_unmanaged_calling_convention_list": return new FunctionPointerUnmanagedCallingConventionList(node);
                case "method_declaration": return new MethodDeclaration(node);
                case "parenthesized_pattern": return new ParenthesizedPattern(node);
                case "ERROR": return new ErrorNode(node);
                default: throw new System.ArgumentException("unknown node type: " + node.Kind, nameof(node));
            }
        }

    
        public string Kind { get; set; }

        protected CSharpLanguageNode(TreeSitter.Node node)
        {
            Kind = node.Kind;
        }
    }
    
    public class CSharpLanguageNodeTerminalNode : CSharpLanguageNode
    {
        public CSharpLanguageNodeTerminalNode(TreeSitter.Node node) : base(node)
        {
        }
    }
    
    public class ErrorNode : CSharpLanguageNode
    {
        public ErrorNode(TreeSitter.Node node) : base(node)
        {
        }
    }

    public interface IDeclaration
    {
    }

    public interface IExpression
    {
    }

    public interface IStatement
    {
    }

    public interface IType
    {
    }

    public class AccessorDeclaration : CSharpLanguageNode
    {
        public CSharpLanguageNode? Body { get; set; }
        public CSharpLanguageNode Name { get; set; }
        public System.Collections.Generic.List<CSharpLanguageNode> Children { get; set; }
        public AccessorDeclaration(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "accessor_declaration");
            
            {
                var tmp = node.ChildByFieldName("body");
                this.Body = tmp is null ? null : (CSharpLanguageNode) CSharpLanguageNode.FromNode(tmp);
            }
            this.Name = (CSharpLanguageNode) CSharpLanguageNode.FromNode(node.ChildByFieldName("name"))!;
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (CSharpLanguageNode) CSharpLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class AccessorList : CSharpLanguageNode
    {
        public System.Collections.Generic.List<AccessorDeclaration> Children { get; set; }
        public AccessorList(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "accessor_list");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => new AccessorDeclaration(x)).ToList();
        }
    }

    public class AliasQualifiedName : CSharpLanguageNode, IType
    {
        public CSharpLanguageNode Alias { get; set; }
        public CSharpLanguageNode Name { get; set; }
        public AliasQualifiedName(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "alias_qualified_name");
            
            this.Alias = (CSharpLanguageNode) CSharpLanguageNode.FromNode(node.ChildByFieldName("alias"))!;
            this.Name = (CSharpLanguageNode) CSharpLanguageNode.FromNode(node.ChildByFieldName("name"))!;
        }
    }

    public class AndPattern : CSharpLanguageNode
    {
        public CSharpLanguageNode Left { get; set; }
        public CSharpLanguageNodeTerminalNode Operator { get; set; }
        public CSharpLanguageNode Right { get; set; }
        public AndPattern(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "and_pattern");
            
            this.Left = (CSharpLanguageNode) CSharpLanguageNode.FromNode(node.ChildByFieldName("left"))!;
            this.Operator = new CSharpLanguageNodeTerminalNode(node.ChildByFieldName("operator"));
            this.Right = (CSharpLanguageNode) CSharpLanguageNode.FromNode(node.ChildByFieldName("right"))!;
        }
    }

    public class AnonymousMethodExpression : CSharpLanguageNode, IExpression
    {
        public ParameterList? Parameters { get; set; }
        public System.Collections.Generic.List<CSharpLanguageNode> Children { get; set; }
        public AnonymousMethodExpression(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "anonymous_method_expression");
            
            {
                var tmp = node.ChildByFieldName("parameters");
                this.Parameters = tmp is null ? null : new ParameterList(tmp);
            }
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (CSharpLanguageNode) CSharpLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class AnonymousObjectCreationExpression : CSharpLanguageNode, IExpression
    {
        public System.Collections.Generic.List<CSharpLanguageNode> Children { get; set; }
        public AnonymousObjectCreationExpression(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "anonymous_object_creation_expression");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (CSharpLanguageNode) CSharpLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class Argument : CSharpLanguageNode
    {
        public NameColon? Name { get; set; }
        public System.Collections.Generic.List<CSharpLanguageNode> Children { get; set; }
        public Argument(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "argument");
            
            {
                var tmp = node.ChildByFieldName("name");
                this.Name = tmp is null ? null : new NameColon(tmp);
            }
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (CSharpLanguageNode) CSharpLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class ArgumentList : CSharpLanguageNode
    {
        public System.Collections.Generic.List<Argument> Children { get; set; }
        public ArgumentList(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "argument_list");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => new Argument(x)).ToList();
        }
    }

    public class ArrayCreationExpression : CSharpLanguageNode, IExpression
    {
        public ArrayType Type { get; set; }
        public System.Collections.Generic.List<InitializerExpression> Children { get; set; }
        public ArrayCreationExpression(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "array_creation_expression");
            
            this.Type = new ArrayType(node.ChildByFieldName("type"));
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => new InitializerExpression(x)).ToList();
        }
    }

    public class ArrayRankSpecifier : CSharpLanguageNode
    {
        public System.Collections.Generic.List<IExpression> Children { get; set; }
        public ArrayRankSpecifier(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "array_rank_specifier");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (IExpression) CSharpLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class ArrayType : CSharpLanguageNode, IType
    {
        public ArrayRankSpecifier Rank { get; set; }
        public CSharpLanguageNode Type { get; set; }
        public ArrayType(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "array_type");
            
            this.Rank = new ArrayRankSpecifier(node.ChildByFieldName("rank"));
            this.Type = (CSharpLanguageNode) CSharpLanguageNode.FromNode(node.ChildByFieldName("type"))!;
        }
    }

    public class ArrowExpressionClause : CSharpLanguageNode
    {
        public System.Collections.Generic.List<IExpression> Children { get; set; }
        public ArrowExpressionClause(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "arrow_expression_clause");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (IExpression) CSharpLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class AsExpression : CSharpLanguageNode, IExpression
    {
        public IExpression Left { get; set; }
        public CSharpLanguageNodeTerminalNode Operator { get; set; }
        public IType Right { get; set; }
        public AsExpression(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "as_expression");
            
            this.Left = (IExpression) CSharpLanguageNode.FromNode(node.ChildByFieldName("left"))!;
            this.Operator = new CSharpLanguageNodeTerminalNode(node.ChildByFieldName("operator"));
            this.Right = (IType) CSharpLanguageNode.FromNode(node.ChildByFieldName("right"))!;
        }
    }

    public class AssignmentExpression : CSharpLanguageNode, IExpression
    {
        public CSharpLanguageNode Left { get; set; }
        public IExpression Right { get; set; }
        public System.Collections.Generic.List<AssignmentOperator> Children { get; set; }
        public AssignmentExpression(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "assignment_expression");
            
            this.Left = (CSharpLanguageNode) CSharpLanguageNode.FromNode(node.ChildByFieldName("left"))!;
            this.Right = (IExpression) CSharpLanguageNode.FromNode(node.ChildByFieldName("right"))!;
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => new AssignmentOperator(x)).ToList();
        }
    }

    public class AssignmentOperator : CSharpLanguageNode
    {
        public AssignmentOperator(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "assignment_operator");
            
        }
    }

    public class Attribute : CSharpLanguageNode
    {
        public CSharpLanguageNode Name { get; set; }
        public System.Collections.Generic.List<AttributeArgumentList> Children { get; set; }
        public Attribute(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "attribute");
            
            this.Name = (CSharpLanguageNode) CSharpLanguageNode.FromNode(node.ChildByFieldName("name"))!;
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => new AttributeArgumentList(x)).ToList();
        }
    }

    public class AttributeArgument : CSharpLanguageNode
    {
        public System.Collections.Generic.List<CSharpLanguageNode> Children { get; set; }
        public AttributeArgument(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "attribute_argument");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (CSharpLanguageNode) CSharpLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class AttributeArgumentList : CSharpLanguageNode
    {
        public System.Collections.Generic.List<AttributeArgument> Children { get; set; }
        public AttributeArgumentList(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "attribute_argument_list");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => new AttributeArgument(x)).ToList();
        }
    }

    public class AttributeList : CSharpLanguageNode
    {
        public System.Collections.Generic.List<CSharpLanguageNode> Children { get; set; }
        public AttributeList(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "attribute_list");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (CSharpLanguageNode) CSharpLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class AttributeTargetSpecifier : CSharpLanguageNode
    {
        public AttributeTargetSpecifier(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "attribute_target_specifier");
            
        }
    }

    public class AwaitExpression : CSharpLanguageNode, IExpression
    {
        public System.Collections.Generic.List<IExpression> Children { get; set; }
        public AwaitExpression(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "await_expression");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (IExpression) CSharpLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class BaseExpression : CSharpLanguageNode, IExpression
    {
        public BaseExpression(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "base_expression");
            
        }
    }

    public class BaseList : CSharpLanguageNode
    {
        public System.Collections.Generic.List<CSharpLanguageNode> Children { get; set; }
        public BaseList(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "base_list");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (CSharpLanguageNode) CSharpLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class BinaryExpression : CSharpLanguageNode, IExpression
    {
        public IExpression Left { get; set; }
        public CSharpLanguageNodeTerminalNode Operator { get; set; }
        public IExpression Right { get; set; }
        public BinaryExpression(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "binary_expression");
            
            this.Left = (IExpression) CSharpLanguageNode.FromNode(node.ChildByFieldName("left"))!;
            this.Operator = new CSharpLanguageNodeTerminalNode(node.ChildByFieldName("operator"));
            this.Right = (IExpression) CSharpLanguageNode.FromNode(node.ChildByFieldName("right"))!;
        }
    }

    public class Block : CSharpLanguageNode, IStatement
    {
        public System.Collections.Generic.List<IStatement> Children { get; set; }
        public Block(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "block");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (IStatement) CSharpLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class BooleanLiteral : CSharpLanguageNode, IExpression
    {
        public BooleanLiteral(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "boolean_literal");
            
        }
    }

    public class BracketedArgumentList : CSharpLanguageNode
    {
        public System.Collections.Generic.List<Argument> Children { get; set; }
        public BracketedArgumentList(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "bracketed_argument_list");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => new Argument(x)).ToList();
        }
    }

    public class BracketedParameterList : CSharpLanguageNode
    {
        public System.Collections.Generic.List<Identifier> Name { get; set; }
        public System.Collections.Generic.List<CSharpLanguageNode> Type { get; set; }
        public System.Collections.Generic.List<CSharpLanguageNode> Children { get; set; }
        public BracketedParameterList(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "bracketed_parameter_list");
            
            this.Name = node.ChildrenByFieldName("name").Select(x => new Identifier(x)).ToList();
            this.Type = node.ChildrenByFieldName("type").Select(x => (CSharpLanguageNode) CSharpLanguageNode.FromNode(x)!).ToList();
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (CSharpLanguageNode) CSharpLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class BreakStatement : CSharpLanguageNode, IStatement
    {
        public BreakStatement(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "break_statement");
            
        }
    }

    public class CasePatternSwitchLabel : CSharpLanguageNode
    {
        public System.Collections.Generic.List<CSharpLanguageNode> Children { get; set; }
        public CasePatternSwitchLabel(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "case_pattern_switch_label");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (CSharpLanguageNode) CSharpLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class CaseSwitchLabel : CSharpLanguageNode
    {
        public System.Collections.Generic.List<IExpression> Children { get; set; }
        public CaseSwitchLabel(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "case_switch_label");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (IExpression) CSharpLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class CastExpression : CSharpLanguageNode, IExpression
    {
        public IType Type { get; set; }
        public IExpression Value { get; set; }
        public CastExpression(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "cast_expression");
            
            this.Type = (IType) CSharpLanguageNode.FromNode(node.ChildByFieldName("type"))!;
            this.Value = (IExpression) CSharpLanguageNode.FromNode(node.ChildByFieldName("value"))!;
        }
    }

    public class CatchClause : CSharpLanguageNode
    {
        public Block Body { get; set; }
        public System.Collections.Generic.List<CSharpLanguageNode> Children { get; set; }
        public CatchClause(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "catch_clause");
            
            this.Body = new Block(node.ChildByFieldName("body"));
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (CSharpLanguageNode) CSharpLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class CatchDeclaration : CSharpLanguageNode
    {
        public Identifier? Name { get; set; }
        public IType Type { get; set; }
        public CatchDeclaration(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "catch_declaration");
            
            {
                var tmp = node.ChildByFieldName("name");
                this.Name = tmp is null ? null : new Identifier(tmp);
            }
            this.Type = (IType) CSharpLanguageNode.FromNode(node.ChildByFieldName("type"))!;
        }
    }

    public class CatchFilterClause : CSharpLanguageNode
    {
        public System.Collections.Generic.List<IExpression> Children { get; set; }
        public CatchFilterClause(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "catch_filter_clause");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (IExpression) CSharpLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class CharacterLiteral : CSharpLanguageNode, IExpression
    {
        public System.Collections.Generic.List<CSharpLanguageNode> Children { get; set; }
        public CharacterLiteral(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "character_literal");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (CSharpLanguageNode) CSharpLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class CheckedExpression : CSharpLanguageNode, IExpression
    {
        public System.Collections.Generic.List<IExpression> Children { get; set; }
        public CheckedExpression(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "checked_expression");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (IExpression) CSharpLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class CheckedStatement : CSharpLanguageNode, IStatement
    {
        public System.Collections.Generic.List<Block> Children { get; set; }
        public CheckedStatement(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "checked_statement");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => new Block(x)).ToList();
        }
    }

    public class ClassDeclaration : CSharpLanguageNode, IDeclaration
    {
        public BaseList? Bases { get; set; }
        public DeclarationList Body { get; set; }
        public Identifier Name { get; set; }
        public TypeParameterList? TypeParameters { get; set; }
        public System.Collections.Generic.List<CSharpLanguageNode> Children { get; set; }
        public ClassDeclaration(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "class_declaration");
            
            {
                var tmp = node.ChildByFieldName("bases");
                this.Bases = tmp is null ? null : new BaseList(tmp);
            }
            this.Body = new DeclarationList(node.ChildByFieldName("body"));
            this.Name = new Identifier(node.ChildByFieldName("name"));
            {
                var tmp = node.ChildByFieldName("type_parameters");
                this.TypeParameters = tmp is null ? null : new TypeParameterList(tmp);
            }
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (CSharpLanguageNode) CSharpLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class CompilationUnit : CSharpLanguageNode
    {
        public System.Collections.Generic.List<CSharpLanguageNode> Children { get; set; }
        public CompilationUnit(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "compilation_unit");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (CSharpLanguageNode) CSharpLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class ConditionalAccessExpression : CSharpLanguageNode, IExpression
    {
        public IExpression Condition { get; set; }
        public System.Collections.Generic.List<CSharpLanguageNode> Children { get; set; }
        public ConditionalAccessExpression(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "conditional_access_expression");
            
            this.Condition = (IExpression) CSharpLanguageNode.FromNode(node.ChildByFieldName("condition"))!;
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (CSharpLanguageNode) CSharpLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class ConditionalExpression : CSharpLanguageNode, IExpression
    {
        public IExpression Alternative { get; set; }
        public IExpression Condition { get; set; }
        public IExpression Consequence { get; set; }
        public ConditionalExpression(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "conditional_expression");
            
            this.Alternative = (IExpression) CSharpLanguageNode.FromNode(node.ChildByFieldName("alternative"))!;
            this.Condition = (IExpression) CSharpLanguageNode.FromNode(node.ChildByFieldName("condition"))!;
            this.Consequence = (IExpression) CSharpLanguageNode.FromNode(node.ChildByFieldName("consequence"))!;
        }
    }

    public class ConstantPattern : CSharpLanguageNode
    {
        public System.Collections.Generic.List<CSharpLanguageNode> Children { get; set; }
        public ConstantPattern(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "constant_pattern");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (CSharpLanguageNode) CSharpLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class ConstructorConstraint : CSharpLanguageNode
    {
        public ConstructorConstraint(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "constructor_constraint");
            
        }
    }

    public class ConstructorDeclaration : CSharpLanguageNode, IDeclaration
    {
        public CSharpLanguageNode? Body { get; set; }
        public Identifier Name { get; set; }
        public ParameterList Parameters { get; set; }
        public System.Collections.Generic.List<CSharpLanguageNode> Children { get; set; }
        public ConstructorDeclaration(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "constructor_declaration");
            
            {
                var tmp = node.ChildByFieldName("body");
                this.Body = tmp is null ? null : (CSharpLanguageNode) CSharpLanguageNode.FromNode(tmp);
            }
            this.Name = new Identifier(node.ChildByFieldName("name"));
            this.Parameters = new ParameterList(node.ChildByFieldName("parameters"));
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (CSharpLanguageNode) CSharpLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class ConstructorInitializer : CSharpLanguageNode
    {
        public System.Collections.Generic.List<ArgumentList> Children { get; set; }
        public ConstructorInitializer(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "constructor_initializer");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => new ArgumentList(x)).ToList();
        }
    }

    public class ContinueStatement : CSharpLanguageNode, IStatement
    {
        public ContinueStatement(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "continue_statement");
            
        }
    }

    public class ConversionOperatorDeclaration : CSharpLanguageNode, IDeclaration
    {
        public CSharpLanguageNode? Body { get; set; }
        public ParameterList Parameters { get; set; }
        public IType Type { get; set; }
        public System.Collections.Generic.List<CSharpLanguageNode> Children { get; set; }
        public ConversionOperatorDeclaration(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "conversion_operator_declaration");
            
            {
                var tmp = node.ChildByFieldName("body");
                this.Body = tmp is null ? null : (CSharpLanguageNode) CSharpLanguageNode.FromNode(tmp);
            }
            this.Parameters = new ParameterList(node.ChildByFieldName("parameters"));
            this.Type = (IType) CSharpLanguageNode.FromNode(node.ChildByFieldName("type"))!;
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (CSharpLanguageNode) CSharpLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class DeclarationExpression : CSharpLanguageNode
    {
        public Identifier Name { get; set; }
        public IType Type { get; set; }
        public DeclarationExpression(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "declaration_expression");
            
            this.Name = new Identifier(node.ChildByFieldName("name"));
            this.Type = (IType) CSharpLanguageNode.FromNode(node.ChildByFieldName("type"))!;
        }
    }

    public class DeclarationList : CSharpLanguageNode
    {
        public System.Collections.Generic.List<IDeclaration> Children { get; set; }
        public DeclarationList(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "declaration_list");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (IDeclaration) CSharpLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class DeclarationPattern : CSharpLanguageNode
    {
        public Identifier? Name { get; set; }
        public IType Type { get; set; }
        public System.Collections.Generic.List<CSharpLanguageNode> Children { get; set; }
        public DeclarationPattern(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "declaration_pattern");
            
            {
                var tmp = node.ChildByFieldName("name");
                this.Name = tmp is null ? null : new Identifier(tmp);
            }
            this.Type = (IType) CSharpLanguageNode.FromNode(node.ChildByFieldName("type"))!;
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (CSharpLanguageNode) CSharpLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class DefaultExpression : CSharpLanguageNode, IExpression
    {
        public IType? Type { get; set; }
        public DefaultExpression(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "default_expression");
            
            {
                var tmp = node.ChildByFieldName("type");
                this.Type = tmp is null ? null : (IType) CSharpLanguageNode.FromNode(tmp);
            }
        }
    }

    public class DefaultSwitchLabel : CSharpLanguageNode
    {
        public DefaultSwitchLabel(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "default_switch_label");
            
        }
    }

    public class DefineDirective : CSharpLanguageNode
    {
        public System.Collections.Generic.List<Identifier> Children { get; set; }
        public DefineDirective(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "define_directive");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => new Identifier(x)).ToList();
        }
    }

    public class DelegateDeclaration : CSharpLanguageNode, IDeclaration
    {
        public Identifier Name { get; set; }
        public ParameterList Parameters { get; set; }
        public IType Type { get; set; }
        public TypeParameterList? TypeParameters { get; set; }
        public System.Collections.Generic.List<CSharpLanguageNode> Children { get; set; }
        public DelegateDeclaration(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "delegate_declaration");
            
            this.Name = new Identifier(node.ChildByFieldName("name"));
            this.Parameters = new ParameterList(node.ChildByFieldName("parameters"));
            this.Type = (IType) CSharpLanguageNode.FromNode(node.ChildByFieldName("type"))!;
            {
                var tmp = node.ChildByFieldName("type_parameters");
                this.TypeParameters = tmp is null ? null : new TypeParameterList(tmp);
            }
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (CSharpLanguageNode) CSharpLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class DestructorDeclaration : CSharpLanguageNode, IDeclaration
    {
        public CSharpLanguageNode? Body { get; set; }
        public Identifier Name { get; set; }
        public ParameterList Parameters { get; set; }
        public System.Collections.Generic.List<AttributeList> Children { get; set; }
        public DestructorDeclaration(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "destructor_declaration");
            
            {
                var tmp = node.ChildByFieldName("body");
                this.Body = tmp is null ? null : (CSharpLanguageNode) CSharpLanguageNode.FromNode(tmp);
            }
            this.Name = new Identifier(node.ChildByFieldName("name"));
            this.Parameters = new ParameterList(node.ChildByFieldName("parameters"));
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => new AttributeList(x)).ToList();
        }
    }

    public class DoStatement : CSharpLanguageNode, IStatement
    {
        public System.Collections.Generic.List<CSharpLanguageNode> Children { get; set; }
        public DoStatement(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "do_statement");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (CSharpLanguageNode) CSharpLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class ElementAccessExpression : CSharpLanguageNode, IExpression
    {
        public IExpression Expression { get; set; }
        public BracketedArgumentList Subscript { get; set; }
        public ElementAccessExpression(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "element_access_expression");
            
            this.Expression = (IExpression) CSharpLanguageNode.FromNode(node.ChildByFieldName("expression"))!;
            this.Subscript = new BracketedArgumentList(node.ChildByFieldName("subscript"));
        }
    }

    public class ElementBindingExpression : CSharpLanguageNode, IExpression
    {
        public System.Collections.Generic.List<BracketedArgumentList> Children { get; set; }
        public ElementBindingExpression(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "element_binding_expression");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => new BracketedArgumentList(x)).ToList();
        }
    }

    public class ElifDirective : CSharpLanguageNode
    {
        public System.Collections.Generic.List<CSharpLanguageNode> Children { get; set; }
        public ElifDirective(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "elif_directive");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (CSharpLanguageNode) CSharpLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class ElseDirective : CSharpLanguageNode
    {
        public ElseDirective(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "else_directive");
            
        }
    }

    public class EmptyStatement : CSharpLanguageNode, IStatement
    {
        public EmptyStatement(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "empty_statement");
            
        }
    }

    public class EndregionDirective : CSharpLanguageNode
    {
        public System.Collections.Generic.List<PreprocMessage> Children { get; set; }
        public EndregionDirective(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "endregion_directive");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => new PreprocMessage(x)).ToList();
        }
    }

    public class EnumDeclaration : CSharpLanguageNode, IDeclaration
    {
        public BaseList? Bases { get; set; }
        public EnumMemberDeclarationList Body { get; set; }
        public Identifier Name { get; set; }
        public System.Collections.Generic.List<CSharpLanguageNode> Children { get; set; }
        public EnumDeclaration(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "enum_declaration");
            
            {
                var tmp = node.ChildByFieldName("bases");
                this.Bases = tmp is null ? null : new BaseList(tmp);
            }
            this.Body = new EnumMemberDeclarationList(node.ChildByFieldName("body"));
            this.Name = new Identifier(node.ChildByFieldName("name"));
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (CSharpLanguageNode) CSharpLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class EnumMemberDeclaration : CSharpLanguageNode
    {
        public Identifier Name { get; set; }
        public IExpression? Value { get; set; }
        public System.Collections.Generic.List<AttributeList> Children { get; set; }
        public EnumMemberDeclaration(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "enum_member_declaration");
            
            this.Name = new Identifier(node.ChildByFieldName("name"));
            {
                var tmp = node.ChildByFieldName("value");
                this.Value = tmp is null ? null : (IExpression) CSharpLanguageNode.FromNode(tmp);
            }
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => new AttributeList(x)).ToList();
        }
    }

    public class EnumMemberDeclarationList : CSharpLanguageNode
    {
        public System.Collections.Generic.List<EnumMemberDeclaration> Children { get; set; }
        public EnumMemberDeclarationList(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "enum_member_declaration_list");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => new EnumMemberDeclaration(x)).ToList();
        }
    }

    public class EqualsValueClause : CSharpLanguageNode
    {
        public System.Collections.Generic.List<IExpression> Children { get; set; }
        public EqualsValueClause(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "equals_value_clause");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (IExpression) CSharpLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class ErrorDirective : CSharpLanguageNode
    {
        public System.Collections.Generic.List<PreprocMessage> Children { get; set; }
        public ErrorDirective(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "error_directive");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => new PreprocMessage(x)).ToList();
        }
    }

    public class EventDeclaration : CSharpLanguageNode, IDeclaration
    {
        public AccessorList? Accessors { get; set; }
        public Identifier Name { get; set; }
        public IType Type { get; set; }
        public System.Collections.Generic.List<CSharpLanguageNode> Children { get; set; }
        public EventDeclaration(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "event_declaration");
            
            {
                var tmp = node.ChildByFieldName("accessors");
                this.Accessors = tmp is null ? null : new AccessorList(tmp);
            }
            this.Name = new Identifier(node.ChildByFieldName("name"));
            this.Type = (IType) CSharpLanguageNode.FromNode(node.ChildByFieldName("type"))!;
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (CSharpLanguageNode) CSharpLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class EventFieldDeclaration : CSharpLanguageNode, IDeclaration
    {
        public System.Collections.Generic.List<CSharpLanguageNode> Children { get; set; }
        public EventFieldDeclaration(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "event_field_declaration");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (CSharpLanguageNode) CSharpLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class ExplicitInterfaceSpecifier : CSharpLanguageNode
    {
        public CSharpLanguageNode Name { get; set; }
        public ExplicitInterfaceSpecifier(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "explicit_interface_specifier");
            
            this.Name = (CSharpLanguageNode) CSharpLanguageNode.FromNode(node.ChildByFieldName("name"))!;
        }
    }

    public class ExpressionColon : CSharpLanguageNode
    {
        public System.Collections.Generic.List<IExpression> Children { get; set; }
        public ExpressionColon(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "expression_colon");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (IExpression) CSharpLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class ExpressionStatement : CSharpLanguageNode, IStatement
    {
        public System.Collections.Generic.List<CSharpLanguageNode> Children { get; set; }
        public ExpressionStatement(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "expression_statement");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (CSharpLanguageNode) CSharpLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class ExternAliasDirective : CSharpLanguageNode
    {
        public Identifier Name { get; set; }
        public ExternAliasDirective(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "extern_alias_directive");
            
            this.Name = new Identifier(node.ChildByFieldName("name"));
        }
    }

    public class FieldDeclaration : CSharpLanguageNode, IDeclaration
    {
        public System.Collections.Generic.List<CSharpLanguageNode> Children { get; set; }
        public FieldDeclaration(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "field_declaration");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (CSharpLanguageNode) CSharpLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class FileScopedNamespaceDeclaration : CSharpLanguageNode
    {
        public CSharpLanguageNode Name { get; set; }
        public System.Collections.Generic.List<CSharpLanguageNode> Children { get; set; }
        public FileScopedNamespaceDeclaration(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "file_scoped_namespace_declaration");
            
            this.Name = (CSharpLanguageNode) CSharpLanguageNode.FromNode(node.ChildByFieldName("name"))!;
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (CSharpLanguageNode) CSharpLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class FinallyClause : CSharpLanguageNode
    {
        public System.Collections.Generic.List<Block> Children { get; set; }
        public FinallyClause(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "finally_clause");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => new Block(x)).ToList();
        }
    }

    public class FixedStatement : CSharpLanguageNode, IStatement
    {
        public System.Collections.Generic.List<CSharpLanguageNode> Children { get; set; }
        public FixedStatement(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "fixed_statement");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (CSharpLanguageNode) CSharpLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class ForEachStatement : CSharpLanguageNode, IStatement
    {
        public IStatement Body { get; set; }
        public CSharpLanguageNode Left { get; set; }
        public IExpression Right { get; set; }
        public IType? Type { get; set; }
        public ForEachStatement(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "for_each_statement");
            
            this.Body = (IStatement) CSharpLanguageNode.FromNode(node.ChildByFieldName("body"))!;
            this.Left = (CSharpLanguageNode) CSharpLanguageNode.FromNode(node.ChildByFieldName("left"))!;
            this.Right = (IExpression) CSharpLanguageNode.FromNode(node.ChildByFieldName("right"))!;
            {
                var tmp = node.ChildByFieldName("type");
                this.Type = tmp is null ? null : (IType) CSharpLanguageNode.FromNode(tmp);
            }
        }
    }

    public class ForStatement : CSharpLanguageNode, IStatement
    {
        public IStatement Body { get; set; }
        public IExpression? Condition { get; set; }
        public System.Collections.Generic.List<CSharpLanguageNode> Initializer { get; set; }
        public System.Collections.Generic.List<CSharpLanguageNode> Update { get; set; }
        public ForStatement(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "for_statement");
            
            this.Body = (IStatement) CSharpLanguageNode.FromNode(node.ChildByFieldName("body"))!;
            {
                var tmp = node.ChildByFieldName("condition");
                this.Condition = tmp is null ? null : (IExpression) CSharpLanguageNode.FromNode(tmp);
            }
            this.Initializer = node.ChildrenByFieldName("initializer").Select(x => (CSharpLanguageNode) CSharpLanguageNode.FromNode(x)!).ToList();
            this.Update = node.ChildrenByFieldName("update").Select(x => (CSharpLanguageNode) CSharpLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class FromClause : CSharpLanguageNode
    {
        public Identifier Name { get; set; }
        public IType? Type { get; set; }
        public System.Collections.Generic.List<IExpression> Children { get; set; }
        public FromClause(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "from_clause");
            
            this.Name = new Identifier(node.ChildByFieldName("name"));
            {
                var tmp = node.ChildByFieldName("type");
                this.Type = tmp is null ? null : (IType) CSharpLanguageNode.FromNode(tmp);
            }
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (IExpression) CSharpLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class FunctionPointerCallingConvention : CSharpLanguageNode
    {
        public System.Collections.Generic.List<FunctionPointerUnmanagedCallingConventionList> Children { get; set; }
        public FunctionPointerCallingConvention(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "function_pointer_calling_convention");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => new FunctionPointerUnmanagedCallingConventionList(x)).ToList();
        }
    }

    public class FunctionPointerParameter : CSharpLanguageNode
    {
        public IType Type { get; set; }
        public System.Collections.Generic.List<ParameterModifier> Children { get; set; }
        public FunctionPointerParameter(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "function_pointer_parameter");
            
            this.Type = (IType) CSharpLanguageNode.FromNode(node.ChildByFieldName("type"))!;
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => new ParameterModifier(x)).ToList();
        }
    }

    public class FunctionPointerType : CSharpLanguageNode, IType
    {
        public System.Collections.Generic.List<CSharpLanguageNode> Children { get; set; }
        public FunctionPointerType(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "function_pointer_type");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (CSharpLanguageNode) CSharpLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class FunctionPointerUnmanagedCallingConvention : CSharpLanguageNode
    {
        public System.Collections.Generic.List<Identifier> Children { get; set; }
        public FunctionPointerUnmanagedCallingConvention(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "function_pointer_unmanaged_calling_convention");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => new Identifier(x)).ToList();
        }
    }

    public class FunctionPointerUnmanagedCallingConventionList : CSharpLanguageNode
    {
        public System.Collections.Generic.List<FunctionPointerUnmanagedCallingConvention> Children { get; set; }
        public FunctionPointerUnmanagedCallingConventionList(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "function_pointer_unmanaged_calling_convention_list");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => new FunctionPointerUnmanagedCallingConvention(x)).ToList();
        }
    }

    public class GenericName : CSharpLanguageNode, IExpression, IType
    {
        public Identifier Name { get; set; }
        public TypeArgumentList TypeArguments { get; set; }
        public GenericName(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "generic_name");
            
            this.Name = new Identifier(node.ChildByFieldName("name"));
            this.TypeArguments = new TypeArgumentList(node.ChildByFieldName("type_arguments"));
        }
    }

    public class Global : CSharpLanguageNode, IExpression, IType
    {
        public Global(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "global");
            
        }
    }

    public class GlobalAttributeList : CSharpLanguageNode
    {
        public System.Collections.Generic.List<Attribute> Children { get; set; }
        public GlobalAttributeList(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "global_attribute_list");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => new Attribute(x)).ToList();
        }
    }

    public class GlobalStatement : CSharpLanguageNode
    {
        public System.Collections.Generic.List<IStatement> Children { get; set; }
        public GlobalStatement(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "global_statement");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (IStatement) CSharpLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class GotoStatement : CSharpLanguageNode, IStatement
    {
        public System.Collections.Generic.List<IExpression> Children { get; set; }
        public GotoStatement(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "goto_statement");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (IExpression) CSharpLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class GroupClause : CSharpLanguageNode
    {
        public System.Collections.Generic.List<IExpression> Children { get; set; }
        public GroupClause(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "group_clause");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (IExpression) CSharpLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class Identifier : CSharpLanguageNode, IExpression, IType
    {
        public Identifier(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "identifier");
            
        }
    }

    public class IfDirective : CSharpLanguageNode
    {
        public System.Collections.Generic.List<CSharpLanguageNode> Children { get; set; }
        public IfDirective(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "if_directive");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (CSharpLanguageNode) CSharpLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class IfStatement : CSharpLanguageNode, IStatement
    {
        public IStatement? Alternative { get; set; }
        public IExpression Condition { get; set; }
        public IStatement Consequence { get; set; }
        public IfStatement(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "if_statement");
            
            {
                var tmp = node.ChildByFieldName("alternative");
                this.Alternative = tmp is null ? null : (IStatement) CSharpLanguageNode.FromNode(tmp);
            }
            this.Condition = (IExpression) CSharpLanguageNode.FromNode(node.ChildByFieldName("condition"))!;
            this.Consequence = (IStatement) CSharpLanguageNode.FromNode(node.ChildByFieldName("consequence"))!;
        }
    }

    public class ImplicitArrayCreationExpression : CSharpLanguageNode, IExpression
    {
        public System.Collections.Generic.List<InitializerExpression> Children { get; set; }
        public ImplicitArrayCreationExpression(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "implicit_array_creation_expression");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => new InitializerExpression(x)).ToList();
        }
    }

    public class ImplicitObjectCreationExpression : CSharpLanguageNode, IExpression
    {
        public System.Collections.Generic.List<CSharpLanguageNode> Children { get; set; }
        public ImplicitObjectCreationExpression(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "implicit_object_creation_expression");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (CSharpLanguageNode) CSharpLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class ImplicitParameterList : CSharpLanguageNode
    {
        public System.Collections.Generic.List<Parameter> Children { get; set; }
        public ImplicitParameterList(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "implicit_parameter_list");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => new Parameter(x)).ToList();
        }
    }

    public class ImplicitStackAllocArrayCreationExpression : CSharpLanguageNode, IExpression
    {
        public System.Collections.Generic.List<InitializerExpression> Children { get; set; }
        public ImplicitStackAllocArrayCreationExpression(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "implicit_stack_alloc_array_creation_expression");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => new InitializerExpression(x)).ToList();
        }
    }

    public class ImplicitType : CSharpLanguageNode, IType
    {
        public ImplicitType(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "implicit_type");
            
        }
    }

    public class IndexerDeclaration : CSharpLanguageNode, IDeclaration
    {
        public AccessorList? Accessors { get; set; }
        public BracketedParameterList Parameters { get; set; }
        public IType Type { get; set; }
        public ArrowExpressionClause? Value { get; set; }
        public System.Collections.Generic.List<CSharpLanguageNode> Children { get; set; }
        public IndexerDeclaration(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "indexer_declaration");
            
            {
                var tmp = node.ChildByFieldName("accessors");
                this.Accessors = tmp is null ? null : new AccessorList(tmp);
            }
            this.Parameters = new BracketedParameterList(node.ChildByFieldName("parameters"));
            this.Type = (IType) CSharpLanguageNode.FromNode(node.ChildByFieldName("type"))!;
            {
                var tmp = node.ChildByFieldName("value");
                this.Value = tmp is null ? null : new ArrowExpressionClause(tmp);
            }
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (CSharpLanguageNode) CSharpLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class InitializerExpression : CSharpLanguageNode, IExpression
    {
        public System.Collections.Generic.List<IExpression> Children { get; set; }
        public InitializerExpression(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "initializer_expression");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (IExpression) CSharpLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class InterfaceDeclaration : CSharpLanguageNode, IDeclaration
    {
        public BaseList? Bases { get; set; }
        public DeclarationList Body { get; set; }
        public Identifier Name { get; set; }
        public TypeParameterList? TypeParameters { get; set; }
        public System.Collections.Generic.List<CSharpLanguageNode> Children { get; set; }
        public InterfaceDeclaration(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "interface_declaration");
            
            {
                var tmp = node.ChildByFieldName("bases");
                this.Bases = tmp is null ? null : new BaseList(tmp);
            }
            this.Body = new DeclarationList(node.ChildByFieldName("body"));
            this.Name = new Identifier(node.ChildByFieldName("name"));
            {
                var tmp = node.ChildByFieldName("type_parameters");
                this.TypeParameters = tmp is null ? null : new TypeParameterList(tmp);
            }
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (CSharpLanguageNode) CSharpLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class InterpolatedRawStringText : CSharpLanguageNode
    {
        public InterpolatedRawStringText(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "interpolated_raw_string_text");
            
        }
    }

    public class InterpolatedStringExpression : CSharpLanguageNode, IExpression
    {
        public System.Collections.Generic.List<CSharpLanguageNode> Children { get; set; }
        public InterpolatedStringExpression(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "interpolated_string_expression");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (CSharpLanguageNode) CSharpLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class InterpolatedStringText : CSharpLanguageNode
    {
        public System.Collections.Generic.List<EscapeSequence> Children { get; set; }
        public InterpolatedStringText(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "interpolated_string_text");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => new EscapeSequence(x)).ToList();
        }
    }

    public class InterpolatedVerbatimStringText : CSharpLanguageNode
    {
        public InterpolatedVerbatimStringText(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "interpolated_verbatim_string_text");
            
        }
    }

    public class Interpolation : CSharpLanguageNode
    {
        public System.Collections.Generic.List<CSharpLanguageNode> Children { get; set; }
        public Interpolation(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "interpolation");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (CSharpLanguageNode) CSharpLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class InterpolationAlignmentClause : CSharpLanguageNode
    {
        public System.Collections.Generic.List<IExpression> Children { get; set; }
        public InterpolationAlignmentClause(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "interpolation_alignment_clause");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (IExpression) CSharpLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class InterpolationFormatClause : CSharpLanguageNode
    {
        public InterpolationFormatClause(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "interpolation_format_clause");
            
        }
    }

    public class InvocationExpression : CSharpLanguageNode, IExpression
    {
        public ArgumentList Arguments { get; set; }
        public IExpression Function { get; set; }
        public InvocationExpression(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "invocation_expression");
            
            this.Arguments = new ArgumentList(node.ChildByFieldName("arguments"));
            this.Function = (IExpression) CSharpLanguageNode.FromNode(node.ChildByFieldName("function"))!;
        }
    }

    public class IsExpression : CSharpLanguageNode, IExpression
    {
        public IExpression Left { get; set; }
        public CSharpLanguageNodeTerminalNode Operator { get; set; }
        public IType Right { get; set; }
        public IsExpression(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "is_expression");
            
            this.Left = (IExpression) CSharpLanguageNode.FromNode(node.ChildByFieldName("left"))!;
            this.Operator = new CSharpLanguageNodeTerminalNode(node.ChildByFieldName("operator"));
            this.Right = (IType) CSharpLanguageNode.FromNode(node.ChildByFieldName("right"))!;
        }
    }

    public class IsPatternExpression : CSharpLanguageNode, IExpression
    {
        public IExpression Expression { get; set; }
        public CSharpLanguageNode Pattern { get; set; }
        public IsPatternExpression(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "is_pattern_expression");
            
            this.Expression = (IExpression) CSharpLanguageNode.FromNode(node.ChildByFieldName("expression"))!;
            this.Pattern = (CSharpLanguageNode) CSharpLanguageNode.FromNode(node.ChildByFieldName("pattern"))!;
        }
    }

    public class JoinClause : CSharpLanguageNode
    {
        public Identifier Name { get; set; }
        public IType? Type { get; set; }
        public System.Collections.Generic.List<CSharpLanguageNode> Children { get; set; }
        public JoinClause(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "join_clause");
            
            this.Name = new Identifier(node.ChildByFieldName("name"));
            {
                var tmp = node.ChildByFieldName("type");
                this.Type = tmp is null ? null : (IType) CSharpLanguageNode.FromNode(tmp);
            }
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (CSharpLanguageNode) CSharpLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class JoinIntoClause : CSharpLanguageNode
    {
        public System.Collections.Generic.List<Identifier> Children { get; set; }
        public JoinIntoClause(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "join_into_clause");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => new Identifier(x)).ToList();
        }
    }

    public class LabeledStatement : CSharpLanguageNode, IStatement
    {
        public System.Collections.Generic.List<CSharpLanguageNode> Children { get; set; }
        public LabeledStatement(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "labeled_statement");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (CSharpLanguageNode) CSharpLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class LambdaExpression : CSharpLanguageNode, IExpression
    {
        public CSharpLanguageNode Body { get; set; }
        public CSharpLanguageNode Parameters { get; set; }
        public IType? Type { get; set; }
        public System.Collections.Generic.List<CSharpLanguageNode> Children { get; set; }
        public LambdaExpression(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "lambda_expression");
            
            this.Body = (CSharpLanguageNode) CSharpLanguageNode.FromNode(node.ChildByFieldName("body"))!;
            this.Parameters = (CSharpLanguageNode) CSharpLanguageNode.FromNode(node.ChildByFieldName("parameters"))!;
            {
                var tmp = node.ChildByFieldName("type");
                this.Type = tmp is null ? null : (IType) CSharpLanguageNode.FromNode(tmp);
            }
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (CSharpLanguageNode) CSharpLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class LetClause : CSharpLanguageNode
    {
        public System.Collections.Generic.List<IExpression> Children { get; set; }
        public LetClause(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "let_clause");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (IExpression) CSharpLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class LineDirective : CSharpLanguageNode
    {
        public System.Collections.Generic.List<CSharpLanguageNode> Children { get; set; }
        public LineDirective(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "line_directive");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (CSharpLanguageNode) CSharpLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class ListPattern : CSharpLanguageNode
    {
        public System.Collections.Generic.List<CSharpLanguageNode> Children { get; set; }
        public ListPattern(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "list_pattern");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (CSharpLanguageNode) CSharpLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class LoadDirective : CSharpLanguageNode
    {
        public System.Collections.Generic.List<PreprocStringLiteral> Children { get; set; }
        public LoadDirective(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "load_directive");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => new PreprocStringLiteral(x)).ToList();
        }
    }

    public class LocalDeclarationStatement : CSharpLanguageNode, IStatement
    {
        public System.Collections.Generic.List<CSharpLanguageNode> Children { get; set; }
        public LocalDeclarationStatement(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "local_declaration_statement");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (CSharpLanguageNode) CSharpLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class LocalFunctionStatement : CSharpLanguageNode, IStatement
    {
        public CSharpLanguageNode? Body { get; set; }
        public Identifier Name { get; set; }
        public ParameterList Parameters { get; set; }
        public IType Type { get; set; }
        public TypeParameterList? TypeParameters { get; set; }
        public System.Collections.Generic.List<CSharpLanguageNode> Children { get; set; }
        public LocalFunctionStatement(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "local_function_statement");
            
            {
                var tmp = node.ChildByFieldName("body");
                this.Body = tmp is null ? null : (CSharpLanguageNode) CSharpLanguageNode.FromNode(tmp);
            }
            this.Name = new Identifier(node.ChildByFieldName("name"));
            this.Parameters = new ParameterList(node.ChildByFieldName("parameters"));
            this.Type = (IType) CSharpLanguageNode.FromNode(node.ChildByFieldName("type"))!;
            {
                var tmp = node.ChildByFieldName("type_parameters");
                this.TypeParameters = tmp is null ? null : new TypeParameterList(tmp);
            }
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (CSharpLanguageNode) CSharpLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class LockStatement : CSharpLanguageNode, IStatement
    {
        public System.Collections.Generic.List<CSharpLanguageNode> Children { get; set; }
        public LockStatement(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "lock_statement");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (CSharpLanguageNode) CSharpLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class MakeRefExpression : CSharpLanguageNode, IExpression
    {
        public System.Collections.Generic.List<IExpression> Children { get; set; }
        public MakeRefExpression(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "make_ref_expression");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (IExpression) CSharpLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class MemberAccessExpression : CSharpLanguageNode, IExpression
    {
        public CSharpLanguageNode Expression { get; set; }
        public CSharpLanguageNode Name { get; set; }
        public MemberAccessExpression(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "member_access_expression");
            
            this.Expression = (CSharpLanguageNode) CSharpLanguageNode.FromNode(node.ChildByFieldName("expression"))!;
            this.Name = (CSharpLanguageNode) CSharpLanguageNode.FromNode(node.ChildByFieldName("name"))!;
        }
    }

    public class MemberBindingExpression : CSharpLanguageNode
    {
        public CSharpLanguageNode Name { get; set; }
        public MemberBindingExpression(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "member_binding_expression");
            
            this.Name = (CSharpLanguageNode) CSharpLanguageNode.FromNode(node.ChildByFieldName("name"))!;
        }
    }

    public class MethodDeclaration : CSharpLanguageNode, IDeclaration
    {
        public CSharpLanguageNode? Body { get; set; }
        public Identifier Name { get; set; }
        public ParameterList Parameters { get; set; }
        public IType Type { get; set; }
        public TypeParameterList? TypeParameters { get; set; }
        public System.Collections.Generic.List<CSharpLanguageNode> Children { get; set; }
        public MethodDeclaration(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "method_declaration");
            
            {
                var tmp = node.ChildByFieldName("body");
                this.Body = tmp is null ? null : (CSharpLanguageNode) CSharpLanguageNode.FromNode(tmp);
            }
            this.Name = new Identifier(node.ChildByFieldName("name"));
            this.Parameters = new ParameterList(node.ChildByFieldName("parameters"));
            this.Type = (IType) CSharpLanguageNode.FromNode(node.ChildByFieldName("type"))!;
            {
                var tmp = node.ChildByFieldName("type_parameters");
                this.TypeParameters = tmp is null ? null : new TypeParameterList(tmp);
            }
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (CSharpLanguageNode) CSharpLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class Modifier : CSharpLanguageNode
    {
        public Modifier(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "modifier");
            
        }
    }

    public class NameColon : CSharpLanguageNode
    {
        public CSharpLanguageNode Name { get; set; }
        public NameColon(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "name_colon");
            
            this.Name = (CSharpLanguageNode) CSharpLanguageNode.FromNode(node.ChildByFieldName("name"))!;
        }
    }

    public class NameEquals : CSharpLanguageNode
    {
        public System.Collections.Generic.List<CSharpLanguageNode> Children { get; set; }
        public NameEquals(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "name_equals");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (CSharpLanguageNode) CSharpLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class NamespaceDeclaration : CSharpLanguageNode, IDeclaration
    {
        public DeclarationList Body { get; set; }
        public CSharpLanguageNode Name { get; set; }
        public NamespaceDeclaration(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "namespace_declaration");
            
            this.Body = new DeclarationList(node.ChildByFieldName("body"));
            this.Name = (CSharpLanguageNode) CSharpLanguageNode.FromNode(node.ChildByFieldName("name"))!;
        }
    }

    public class NegatedPattern : CSharpLanguageNode
    {
        public System.Collections.Generic.List<CSharpLanguageNode> Children { get; set; }
        public NegatedPattern(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "negated_pattern");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (CSharpLanguageNode) CSharpLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class NullableDirective : CSharpLanguageNode
    {
        public NullableDirective(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "nullable_directive");
            
        }
    }

    public class NullableType : CSharpLanguageNode, IType
    {
        public CSharpLanguageNode Type { get; set; }
        public NullableType(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "nullable_type");
            
            this.Type = (CSharpLanguageNode) CSharpLanguageNode.FromNode(node.ChildByFieldName("type"))!;
        }
    }

    public class ObjectCreationExpression : CSharpLanguageNode, IExpression
    {
        public ArgumentList? Arguments { get; set; }
        public InitializerExpression? Initializer { get; set; }
        public CSharpLanguageNode Type { get; set; }
        public ObjectCreationExpression(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "object_creation_expression");
            
            {
                var tmp = node.ChildByFieldName("arguments");
                this.Arguments = tmp is null ? null : new ArgumentList(tmp);
            }
            {
                var tmp = node.ChildByFieldName("initializer");
                this.Initializer = tmp is null ? null : new InitializerExpression(tmp);
            }
            this.Type = (CSharpLanguageNode) CSharpLanguageNode.FromNode(node.ChildByFieldName("type"))!;
        }
    }

    public class OperatorDeclaration : CSharpLanguageNode, IDeclaration
    {
        public CSharpLanguageNode? Body { get; set; }
        public CSharpLanguageNodeTerminalNode Operator { get; set; }
        public ParameterList Parameters { get; set; }
        public IType Type { get; set; }
        public System.Collections.Generic.List<CSharpLanguageNode> Children { get; set; }
        public OperatorDeclaration(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "operator_declaration");
            
            {
                var tmp = node.ChildByFieldName("body");
                this.Body = tmp is null ? null : (CSharpLanguageNode) CSharpLanguageNode.FromNode(tmp);
            }
            this.Operator = new CSharpLanguageNodeTerminalNode(node.ChildByFieldName("operator"));
            this.Parameters = new ParameterList(node.ChildByFieldName("parameters"));
            this.Type = (IType) CSharpLanguageNode.FromNode(node.ChildByFieldName("type"))!;
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (CSharpLanguageNode) CSharpLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class OrPattern : CSharpLanguageNode
    {
        public CSharpLanguageNode Left { get; set; }
        public CSharpLanguageNodeTerminalNode Operator { get; set; }
        public CSharpLanguageNode Right { get; set; }
        public OrPattern(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "or_pattern");
            
            this.Left = (CSharpLanguageNode) CSharpLanguageNode.FromNode(node.ChildByFieldName("left"))!;
            this.Operator = new CSharpLanguageNodeTerminalNode(node.ChildByFieldName("operator"));
            this.Right = (CSharpLanguageNode) CSharpLanguageNode.FromNode(node.ChildByFieldName("right"))!;
        }
    }

    public class OrderByClause : CSharpLanguageNode
    {
        public System.Collections.Generic.List<IExpression> Children { get; set; }
        public OrderByClause(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "order_by_clause");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (IExpression) CSharpLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class Parameter : CSharpLanguageNode
    {
        public Identifier Name { get; set; }
        public CSharpLanguageNode? Type { get; set; }
        public System.Collections.Generic.List<CSharpLanguageNode> Children { get; set; }
        public Parameter(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "parameter");
            
            this.Name = new Identifier(node.ChildByFieldName("name"));
            {
                var tmp = node.ChildByFieldName("type");
                this.Type = tmp is null ? null : (CSharpLanguageNode) CSharpLanguageNode.FromNode(tmp);
            }
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (CSharpLanguageNode) CSharpLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class ParameterList : CSharpLanguageNode
    {
        public System.Collections.Generic.List<Identifier> Name { get; set; }
        public System.Collections.Generic.List<CSharpLanguageNode> Type { get; set; }
        public System.Collections.Generic.List<CSharpLanguageNode> Children { get; set; }
        public ParameterList(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "parameter_list");
            
            this.Name = node.ChildrenByFieldName("name").Select(x => new Identifier(x)).ToList();
            this.Type = node.ChildrenByFieldName("type").Select(x => (CSharpLanguageNode) CSharpLanguageNode.FromNode(x)!).ToList();
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (CSharpLanguageNode) CSharpLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class ParenthesizedExpression : CSharpLanguageNode, IExpression
    {
        public System.Collections.Generic.List<CSharpLanguageNode> Children { get; set; }
        public ParenthesizedExpression(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "parenthesized_expression");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (CSharpLanguageNode) CSharpLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class ParenthesizedPattern : CSharpLanguageNode
    {
        public System.Collections.Generic.List<CSharpLanguageNode> Children { get; set; }
        public ParenthesizedPattern(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "parenthesized_pattern");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (CSharpLanguageNode) CSharpLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class ParenthesizedVariableDesignation : CSharpLanguageNode
    {
        public System.Collections.Generic.List<Identifier> Name { get; set; }
        public System.Collections.Generic.List<CSharpLanguageNode> Children { get; set; }
        public ParenthesizedVariableDesignation(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "parenthesized_variable_designation");
            
            this.Name = node.ChildrenByFieldName("name").Select(x => new Identifier(x)).ToList();
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (CSharpLanguageNode) CSharpLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class PointerType : CSharpLanguageNode, IType
    {
        public CSharpLanguageNode Type { get; set; }
        public PointerType(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "pointer_type");
            
            this.Type = (CSharpLanguageNode) CSharpLanguageNode.FromNode(node.ChildByFieldName("type"))!;
        }
    }

    public class PositionalPatternClause : CSharpLanguageNode
    {
        public System.Collections.Generic.List<Subpattern> Children { get; set; }
        public PositionalPatternClause(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "positional_pattern_clause");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => new Subpattern(x)).ToList();
        }
    }

    public class PostfixUnaryExpression : CSharpLanguageNode, IExpression
    {
        public System.Collections.Generic.List<IExpression> Children { get; set; }
        public PostfixUnaryExpression(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "postfix_unary_expression");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (IExpression) CSharpLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class PragmaDirective : CSharpLanguageNode
    {
        public System.Collections.Generic.List<CSharpLanguageNode> Children { get; set; }
        public PragmaDirective(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "pragma_directive");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (CSharpLanguageNode) CSharpLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class PrefixUnaryExpression : CSharpLanguageNode, IExpression
    {
        public CSharpLanguageNode? Argument { get; set; }
        public CSharpLanguageNodeTerminalNode? Operator { get; set; }
        public System.Collections.Generic.List<IExpression> Children { get; set; }
        public PrefixUnaryExpression(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "prefix_unary_expression");
            
            {
                var tmp = node.ChildByFieldName("argument");
                this.Argument = tmp is null ? null : (CSharpLanguageNode) CSharpLanguageNode.FromNode(tmp);
            }
            {
                var tmp = node.ChildByFieldName("operator");
                this.Operator = tmp is null ? null : new CSharpLanguageNodeTerminalNode(tmp);
            }
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (IExpression) CSharpLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class PrimaryConstructorBaseType : CSharpLanguageNode
    {
        public CSharpLanguageNode Type { get; set; }
        public System.Collections.Generic.List<ArgumentList> Children { get; set; }
        public PrimaryConstructorBaseType(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "primary_constructor_base_type");
            
            this.Type = (CSharpLanguageNode) CSharpLanguageNode.FromNode(node.ChildByFieldName("type"))!;
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => new ArgumentList(x)).ToList();
        }
    }

    public class PropertyDeclaration : CSharpLanguageNode, IDeclaration
    {
        public AccessorList? Accessors { get; set; }
        public Identifier Name { get; set; }
        public IType Type { get; set; }
        public CSharpLanguageNode? Value { get; set; }
        public System.Collections.Generic.List<CSharpLanguageNode> Children { get; set; }
        public PropertyDeclaration(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "property_declaration");
            
            {
                var tmp = node.ChildByFieldName("accessors");
                this.Accessors = tmp is null ? null : new AccessorList(tmp);
            }
            this.Name = new Identifier(node.ChildByFieldName("name"));
            this.Type = (IType) CSharpLanguageNode.FromNode(node.ChildByFieldName("type"))!;
            {
                var tmp = node.ChildByFieldName("value");
                this.Value = tmp is null ? null : (CSharpLanguageNode) CSharpLanguageNode.FromNode(tmp);
            }
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (CSharpLanguageNode) CSharpLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class PropertyPatternClause : CSharpLanguageNode
    {
        public System.Collections.Generic.List<Subpattern> Children { get; set; }
        public PropertyPatternClause(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "property_pattern_clause");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => new Subpattern(x)).ToList();
        }
    }

    public class QualifiedName : CSharpLanguageNode, IType
    {
        public CSharpLanguageNode Name { get; set; }
        public CSharpLanguageNode Qualifier { get; set; }
        public QualifiedName(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "qualified_name");
            
            this.Name = (CSharpLanguageNode) CSharpLanguageNode.FromNode(node.ChildByFieldName("name"))!;
            this.Qualifier = (CSharpLanguageNode) CSharpLanguageNode.FromNode(node.ChildByFieldName("qualifier"))!;
        }
    }

    public class QueryContinuation : CSharpLanguageNode
    {
        public Identifier Name { get; set; }
        public System.Collections.Generic.List<CSharpLanguageNode> Children { get; set; }
        public QueryContinuation(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "query_continuation");
            
            this.Name = new Identifier(node.ChildByFieldName("name"));
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (CSharpLanguageNode) CSharpLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class QueryExpression : CSharpLanguageNode, IExpression
    {
        public System.Collections.Generic.List<CSharpLanguageNode> Children { get; set; }
        public QueryExpression(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "query_expression");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (CSharpLanguageNode) CSharpLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class RangeExpression : CSharpLanguageNode, IExpression
    {
        public System.Collections.Generic.List<IExpression> Children { get; set; }
        public RangeExpression(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "range_expression");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (IExpression) CSharpLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class RecordDeclaration : CSharpLanguageNode, IDeclaration
    {
        public BaseList? Bases { get; set; }
        public CSharpLanguageNode Body { get; set; }
        public Identifier Name { get; set; }
        public ParameterList? Parameters { get; set; }
        public TypeParameterList? TypeParameters { get; set; }
        public System.Collections.Generic.List<CSharpLanguageNode> Children { get; set; }
        public RecordDeclaration(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "record_declaration");
            
            {
                var tmp = node.ChildByFieldName("bases");
                this.Bases = tmp is null ? null : new BaseList(tmp);
            }
            this.Body = (CSharpLanguageNode) CSharpLanguageNode.FromNode(node.ChildByFieldName("body"))!;
            this.Name = new Identifier(node.ChildByFieldName("name"));
            {
                var tmp = node.ChildByFieldName("parameters");
                this.Parameters = tmp is null ? null : new ParameterList(tmp);
            }
            {
                var tmp = node.ChildByFieldName("type_parameters");
                this.TypeParameters = tmp is null ? null : new TypeParameterList(tmp);
            }
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (CSharpLanguageNode) CSharpLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class RecordStructDeclaration : CSharpLanguageNode, IDeclaration
    {
        public BaseList? Bases { get; set; }
        public CSharpLanguageNode Body { get; set; }
        public Identifier Name { get; set; }
        public ParameterList? Parameters { get; set; }
        public TypeParameterList? TypeParameters { get; set; }
        public System.Collections.Generic.List<CSharpLanguageNode> Children { get; set; }
        public RecordStructDeclaration(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "record_struct_declaration");
            
            {
                var tmp = node.ChildByFieldName("bases");
                this.Bases = tmp is null ? null : new BaseList(tmp);
            }
            this.Body = (CSharpLanguageNode) CSharpLanguageNode.FromNode(node.ChildByFieldName("body"))!;
            this.Name = new Identifier(node.ChildByFieldName("name"));
            {
                var tmp = node.ChildByFieldName("parameters");
                this.Parameters = tmp is null ? null : new ParameterList(tmp);
            }
            {
                var tmp = node.ChildByFieldName("type_parameters");
                this.TypeParameters = tmp is null ? null : new TypeParameterList(tmp);
            }
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (CSharpLanguageNode) CSharpLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class RecursivePattern : CSharpLanguageNode
    {
        public Identifier? Name { get; set; }
        public IType? Type { get; set; }
        public System.Collections.Generic.List<CSharpLanguageNode> Children { get; set; }
        public RecursivePattern(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "recursive_pattern");
            
            {
                var tmp = node.ChildByFieldName("name");
                this.Name = tmp is null ? null : new Identifier(tmp);
            }
            {
                var tmp = node.ChildByFieldName("type");
                this.Type = tmp is null ? null : (IType) CSharpLanguageNode.FromNode(tmp);
            }
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (CSharpLanguageNode) CSharpLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class RefExpression : CSharpLanguageNode, IExpression
    {
        public System.Collections.Generic.List<IExpression> Children { get; set; }
        public RefExpression(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "ref_expression");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (IExpression) CSharpLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class RefType : CSharpLanguageNode, IType
    {
        public CSharpLanguageNode Type { get; set; }
        public RefType(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "ref_type");
            
            this.Type = (CSharpLanguageNode) CSharpLanguageNode.FromNode(node.ChildByFieldName("type"))!;
        }
    }

    public class RefTypeExpression : CSharpLanguageNode, IExpression
    {
        public System.Collections.Generic.List<IExpression> Children { get; set; }
        public RefTypeExpression(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "ref_type_expression");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (IExpression) CSharpLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class RefValueExpression : CSharpLanguageNode, IExpression
    {
        public IType Type { get; set; }
        public IExpression Value { get; set; }
        public RefValueExpression(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "ref_value_expression");
            
            this.Type = (IType) CSharpLanguageNode.FromNode(node.ChildByFieldName("type"))!;
            this.Value = (IExpression) CSharpLanguageNode.FromNode(node.ChildByFieldName("value"))!;
        }
    }

    public class ReferenceDirective : CSharpLanguageNode
    {
        public System.Collections.Generic.List<PreprocStringLiteral> Children { get; set; }
        public ReferenceDirective(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "reference_directive");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => new PreprocStringLiteral(x)).ToList();
        }
    }

    public class RegionDirective : CSharpLanguageNode
    {
        public System.Collections.Generic.List<PreprocMessage> Children { get; set; }
        public RegionDirective(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "region_directive");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => new PreprocMessage(x)).ToList();
        }
    }

    public class RelationalPattern : CSharpLanguageNode
    {
        public System.Collections.Generic.List<IExpression> Children { get; set; }
        public RelationalPattern(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "relational_pattern");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (IExpression) CSharpLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class ReturnStatement : CSharpLanguageNode, IStatement
    {
        public System.Collections.Generic.List<IExpression> Children { get; set; }
        public ReturnStatement(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "return_statement");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (IExpression) CSharpLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class ScopedType : CSharpLanguageNode, IType
    {
        public CSharpLanguageNode Type { get; set; }
        public ScopedType(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "scoped_type");
            
            this.Type = (CSharpLanguageNode) CSharpLanguageNode.FromNode(node.ChildByFieldName("type"))!;
        }
    }

    public class SelectClause : CSharpLanguageNode
    {
        public System.Collections.Generic.List<IExpression> Children { get; set; }
        public SelectClause(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "select_clause");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (IExpression) CSharpLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class ShebangDirective : CSharpLanguageNode
    {
        public ShebangDirective(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "shebang_directive");
            
        }
    }

    public class SimpleAssignmentExpression : CSharpLanguageNode
    {
        public System.Collections.Generic.List<IExpression> Children { get; set; }
        public SimpleAssignmentExpression(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "simple_assignment_expression");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (IExpression) CSharpLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class SizeOfExpression : CSharpLanguageNode, IExpression
    {
        public IType Type { get; set; }
        public SizeOfExpression(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "size_of_expression");
            
            this.Type = (IType) CSharpLanguageNode.FromNode(node.ChildByFieldName("type"))!;
        }
    }

    public class SlicePattern : CSharpLanguageNode
    {
        public SlicePattern(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "slice_pattern");
            
        }
    }

    public class StackAllocArrayCreationExpression : CSharpLanguageNode, IExpression
    {
        public ArrayType Type { get; set; }
        public System.Collections.Generic.List<InitializerExpression> Children { get; set; }
        public StackAllocArrayCreationExpression(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "stack_alloc_array_creation_expression");
            
            this.Type = new ArrayType(node.ChildByFieldName("type"));
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => new InitializerExpression(x)).ToList();
        }
    }

    public class StringLiteral : CSharpLanguageNode, IExpression
    {
        public System.Collections.Generic.List<CSharpLanguageNode> Children { get; set; }
        public StringLiteral(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "string_literal");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (CSharpLanguageNode) CSharpLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class StructDeclaration : CSharpLanguageNode, IDeclaration
    {
        public BaseList? Bases { get; set; }
        public DeclarationList Body { get; set; }
        public Identifier Name { get; set; }
        public TypeParameterList? TypeParameters { get; set; }
        public System.Collections.Generic.List<CSharpLanguageNode> Children { get; set; }
        public StructDeclaration(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "struct_declaration");
            
            {
                var tmp = node.ChildByFieldName("bases");
                this.Bases = tmp is null ? null : new BaseList(tmp);
            }
            this.Body = new DeclarationList(node.ChildByFieldName("body"));
            this.Name = new Identifier(node.ChildByFieldName("name"));
            {
                var tmp = node.ChildByFieldName("type_parameters");
                this.TypeParameters = tmp is null ? null : new TypeParameterList(tmp);
            }
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (CSharpLanguageNode) CSharpLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class Subpattern : CSharpLanguageNode
    {
        public System.Collections.Generic.List<CSharpLanguageNode> Children { get; set; }
        public Subpattern(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "subpattern");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (CSharpLanguageNode) CSharpLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class SwitchBody : CSharpLanguageNode
    {
        public System.Collections.Generic.List<SwitchSection> Children { get; set; }
        public SwitchBody(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "switch_body");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => new SwitchSection(x)).ToList();
        }
    }

    public class SwitchExpression : CSharpLanguageNode, IExpression
    {
        public System.Collections.Generic.List<CSharpLanguageNode> Children { get; set; }
        public SwitchExpression(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "switch_expression");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (CSharpLanguageNode) CSharpLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class SwitchExpressionArm : CSharpLanguageNode
    {
        public System.Collections.Generic.List<CSharpLanguageNode> Children { get; set; }
        public SwitchExpressionArm(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "switch_expression_arm");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (CSharpLanguageNode) CSharpLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class SwitchSection : CSharpLanguageNode
    {
        public System.Collections.Generic.List<CSharpLanguageNode> Children { get; set; }
        public SwitchSection(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "switch_section");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (CSharpLanguageNode) CSharpLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class SwitchStatement : CSharpLanguageNode, IStatement
    {
        public SwitchBody Body { get; set; }
        public IExpression Value { get; set; }
        public SwitchStatement(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "switch_statement");
            
            this.Body = new SwitchBody(node.ChildByFieldName("body"));
            this.Value = (IExpression) CSharpLanguageNode.FromNode(node.ChildByFieldName("value"))!;
        }
    }

    public class ThisExpression : CSharpLanguageNode, IExpression
    {
        public ThisExpression(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "this_expression");
            
        }
    }

    public class ThrowExpression : CSharpLanguageNode, IExpression
    {
        public System.Collections.Generic.List<IExpression> Children { get; set; }
        public ThrowExpression(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "throw_expression");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (IExpression) CSharpLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class ThrowStatement : CSharpLanguageNode, IStatement
    {
        public System.Collections.Generic.List<IExpression> Children { get; set; }
        public ThrowStatement(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "throw_statement");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (IExpression) CSharpLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class TryStatement : CSharpLanguageNode, IStatement
    {
        public Block Body { get; set; }
        public System.Collections.Generic.List<CSharpLanguageNode> Children { get; set; }
        public TryStatement(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "try_statement");
            
            this.Body = new Block(node.ChildByFieldName("body"));
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (CSharpLanguageNode) CSharpLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class TupleElement : CSharpLanguageNode
    {
        public Identifier? Name { get; set; }
        public IType Type { get; set; }
        public TupleElement(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "tuple_element");
            
            {
                var tmp = node.ChildByFieldName("name");
                this.Name = tmp is null ? null : new Identifier(tmp);
            }
            this.Type = (IType) CSharpLanguageNode.FromNode(node.ChildByFieldName("type"))!;
        }
    }

    public class TupleExpression : CSharpLanguageNode, IExpression
    {
        public System.Collections.Generic.List<Argument> Children { get; set; }
        public TupleExpression(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "tuple_expression");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => new Argument(x)).ToList();
        }
    }

    public class TuplePattern : CSharpLanguageNode
    {
        public System.Collections.Generic.List<Identifier> Name { get; set; }
        public System.Collections.Generic.List<CSharpLanguageNode> Children { get; set; }
        public TuplePattern(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "tuple_pattern");
            
            this.Name = node.ChildrenByFieldName("name").Select(x => new Identifier(x)).ToList();
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (CSharpLanguageNode) CSharpLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class TupleType : CSharpLanguageNode, IType
    {
        public System.Collections.Generic.List<TupleElement> Children { get; set; }
        public TupleType(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "tuple_type");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => new TupleElement(x)).ToList();
        }
    }

    public class TypeArgumentList : CSharpLanguageNode
    {
        public System.Collections.Generic.List<IType> Children { get; set; }
        public TypeArgumentList(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "type_argument_list");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (IType) CSharpLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class TypeConstraint : CSharpLanguageNode
    {
        public IType Type { get; set; }
        public TypeConstraint(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "type_constraint");
            
            this.Type = (IType) CSharpLanguageNode.FromNode(node.ChildByFieldName("type"))!;
        }
    }

    public class TypeOfExpression : CSharpLanguageNode, IExpression
    {
        public IType Type { get; set; }
        public TypeOfExpression(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "type_of_expression");
            
            this.Type = (IType) CSharpLanguageNode.FromNode(node.ChildByFieldName("type"))!;
        }
    }

    public class TypeParameter : CSharpLanguageNode
    {
        public Identifier Name { get; set; }
        public System.Collections.Generic.List<AttributeList> Children { get; set; }
        public TypeParameter(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "type_parameter");
            
            this.Name = new Identifier(node.ChildByFieldName("name"));
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => new AttributeList(x)).ToList();
        }
    }

    public class TypeParameterConstraint : CSharpLanguageNode
    {
        public System.Collections.Generic.List<CSharpLanguageNode> Children { get; set; }
        public TypeParameterConstraint(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "type_parameter_constraint");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (CSharpLanguageNode) CSharpLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class TypeParameterConstraintsClause : CSharpLanguageNode
    {
        public System.Collections.Generic.List<CSharpLanguageNode> Constraints { get; set; }
        public CSharpLanguageNode Target { get; set; }
        public TypeParameterConstraintsClause(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "type_parameter_constraints_clause");
            
            this.Constraints = node.ChildrenByFieldName("constraints").Select(x => (CSharpLanguageNode) CSharpLanguageNode.FromNode(x)!).ToList();
            this.Target = (CSharpLanguageNode) CSharpLanguageNode.FromNode(node.ChildByFieldName("target"))!;
        }
    }

    public class TypeParameterList : CSharpLanguageNode
    {
        public System.Collections.Generic.List<TypeParameter> Children { get; set; }
        public TypeParameterList(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "type_parameter_list");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => new TypeParameter(x)).ToList();
        }
    }

    public class TypePattern : CSharpLanguageNode
    {
        public IType Type { get; set; }
        public TypePattern(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "type_pattern");
            
            this.Type = (IType) CSharpLanguageNode.FromNode(node.ChildByFieldName("type"))!;
        }
    }

    public class UndefDirective : CSharpLanguageNode
    {
        public System.Collections.Generic.List<Identifier> Children { get; set; }
        public UndefDirective(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "undef_directive");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => new Identifier(x)).ToList();
        }
    }

    public class UnsafeStatement : CSharpLanguageNode, IStatement
    {
        public System.Collections.Generic.List<Block> Children { get; set; }
        public UnsafeStatement(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "unsafe_statement");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => new Block(x)).ToList();
        }
    }

    public class UsingDirective : CSharpLanguageNode, IDeclaration
    {
        public NameEquals? Alias { get; set; }
        public CSharpLanguageNode Name { get; set; }
        public UsingDirective(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "using_directive");
            
            {
                var tmp = node.ChildByFieldName("alias");
                this.Alias = tmp is null ? null : new NameEquals(tmp);
            }
            this.Name = (CSharpLanguageNode) CSharpLanguageNode.FromNode(node.ChildByFieldName("name"))!;
        }
    }

    public class UsingStatement : CSharpLanguageNode, IStatement
    {
        public IStatement Body { get; set; }
        public System.Collections.Generic.List<CSharpLanguageNode> Children { get; set; }
        public UsingStatement(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "using_statement");
            
            this.Body = (IStatement) CSharpLanguageNode.FromNode(node.ChildByFieldName("body"))!;
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (CSharpLanguageNode) CSharpLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class VarPattern : CSharpLanguageNode
    {
        public Identifier? Name { get; set; }
        public System.Collections.Generic.List<CSharpLanguageNode> Children { get; set; }
        public VarPattern(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "var_pattern");
            
            {
                var tmp = node.ChildByFieldName("name");
                this.Name = tmp is null ? null : new Identifier(tmp);
            }
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (CSharpLanguageNode) CSharpLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class VariableDeclaration : CSharpLanguageNode
    {
        public IType Type { get; set; }
        public System.Collections.Generic.List<VariableDeclarator> Children { get; set; }
        public VariableDeclaration(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "variable_declaration");
            
            this.Type = (IType) CSharpLanguageNode.FromNode(node.ChildByFieldName("type"))!;
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => new VariableDeclarator(x)).ToList();
        }
    }

    public class VariableDeclarator : CSharpLanguageNode
    {
        public Identifier? Name { get; set; }
        public System.Collections.Generic.List<CSharpLanguageNode> Children { get; set; }
        public VariableDeclarator(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "variable_declarator");
            
            {
                var tmp = node.ChildByFieldName("name");
                this.Name = tmp is null ? null : new Identifier(tmp);
            }
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (CSharpLanguageNode) CSharpLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class WarningDirective : CSharpLanguageNode
    {
        public System.Collections.Generic.List<PreprocMessage> Children { get; set; }
        public WarningDirective(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "warning_directive");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => new PreprocMessage(x)).ToList();
        }
    }

    public class WhenClause : CSharpLanguageNode
    {
        public System.Collections.Generic.List<IExpression> Children { get; set; }
        public WhenClause(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "when_clause");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (IExpression) CSharpLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class WhereClause : CSharpLanguageNode
    {
        public System.Collections.Generic.List<IExpression> Children { get; set; }
        public WhereClause(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "where_clause");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (IExpression) CSharpLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class WhileStatement : CSharpLanguageNode, IStatement
    {
        public System.Collections.Generic.List<CSharpLanguageNode> Children { get; set; }
        public WhileStatement(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "while_statement");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (CSharpLanguageNode) CSharpLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class WithExpression : CSharpLanguageNode, IExpression
    {
        public System.Collections.Generic.List<CSharpLanguageNode> Children { get; set; }
        public WithExpression(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "with_expression");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (CSharpLanguageNode) CSharpLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class WithInitializerExpression : CSharpLanguageNode
    {
        public System.Collections.Generic.List<SimpleAssignmentExpression> Children { get; set; }
        public WithInitializerExpression(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "with_initializer_expression");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => new SimpleAssignmentExpression(x)).ToList();
        }
    }

    public class YieldStatement : CSharpLanguageNode, IStatement
    {
        public System.Collections.Generic.List<IExpression> Children { get; set; }
        public YieldStatement(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "yield_statement");
            
            this.Children = node.NamedChildrenWithFields
                .Where(x => x.Key == null && !x.Value.IsExtra)
                .Select(x => x.Value)
                .Select(x => (IExpression) CSharpLanguageNode.FromNode(x)!).ToList();
        }
    }

    public class CharacterLiteralUnescaped : CSharpLanguageNode
    {
        public CharacterLiteralUnescaped(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "character_literal_unescaped");
            
        }
    }

    public class Comment : CSharpLanguageNode
    {
        public Comment(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "comment");
            
        }
    }

    public class Discard : CSharpLanguageNode
    {
        public Discard(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "discard");
            
        }
    }

    public class EndifDirective : CSharpLanguageNode
    {
        public EndifDirective(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "endif_directive");
            
        }
    }

    public class EscapeSequence : CSharpLanguageNode
    {
        public EscapeSequence(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "escape_sequence");
            
        }
    }

    public class IntegerLiteral : CSharpLanguageNode, IExpression
    {
        public IntegerLiteral(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "integer_literal");
            
        }
    }

    public class NullLiteral : CSharpLanguageNode, IExpression
    {
        public NullLiteral(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "null_literal");
            
        }
    }

    public class ParameterModifier : CSharpLanguageNode
    {
        public ParameterModifier(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "parameter_modifier");
            
        }
    }

    public class PredefinedType : CSharpLanguageNode, IType
    {
        public PredefinedType(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "predefined_type");
            
        }
    }

    public class PreprocIntegerLiteral : CSharpLanguageNode
    {
        public PreprocIntegerLiteral(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "preproc_integer_literal");
            
        }
    }

    public class PreprocMessage : CSharpLanguageNode
    {
        public PreprocMessage(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "preproc_message");
            
        }
    }

    public class PreprocStringLiteral : CSharpLanguageNode
    {
        public PreprocStringLiteral(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "preproc_string_literal");
            
        }
    }

    public class RawStringLiteral : CSharpLanguageNode, IExpression
    {
        public RawStringLiteral(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "raw_string_literal");
            
        }
    }

    public class RealLiteral : CSharpLanguageNode, IExpression
    {
        public RealLiteral(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "real_literal");
            
        }
    }

    public class StringLiteralEncoding : CSharpLanguageNode
    {
        public StringLiteralEncoding(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "string_literal_encoding");
            
        }
    }

    public class StringLiteralFragment : CSharpLanguageNode
    {
        public StringLiteralFragment(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "string_literal_fragment");
            
        }
    }

    public class VerbatimStringLiteral : CSharpLanguageNode, IExpression
    {
        public VerbatimStringLiteral(TreeSitter.Node node) : base(node)
        {
            System.Diagnostics.Debug.Assert(node.Kind == "verbatim_string_literal");
            
        }
    }
}